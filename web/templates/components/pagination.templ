package components

import (
	"fmt"
)

type Pagination struct {
	CurrentPage int
	TotalPages  int
	TotalItems  int
	PerPage     int
}

templ PaginationComponent(pagination Pagination) {
	<div class="flex items-center justify-between border-t border-gray-200 bg-white px-4 py-3 sm:px-6 rounded-lg">
		<div class="flex flex-1 justify-between sm:hidden">
			if pagination.CurrentPage > 1 {
				<a 
					href={ templ.URL(fmt.Sprintf("?page=%d", pagination.CurrentPage-1)) }
					class="relative inline-flex items-center rounded-md border border-gray-300 bg-white px-4 py-2 text-sm font-medium text-gray-700 hover:bg-gray-50"
				>
					Previous
				</a>
			}
			if pagination.CurrentPage < pagination.TotalPages {
				<a 
					href={ templ.URL(fmt.Sprintf("?page=%d", pagination.CurrentPage+1)) }
					class="relative ml-3 inline-flex items-center rounded-md border border-gray-300 bg-white px-4 py-2 text-sm font-medium text-gray-700 hover:bg-gray-50"
				>
					Next
				</a>
			}
		</div>
		
		<div class="hidden sm:flex sm:flex-1 sm:items-center sm:justify-between">
			<div>
				<p class="text-sm text-gray-700">
					Showing 
					<span class="font-medium">{ fmt.Sprintf("%d", (pagination.CurrentPage-1)*pagination.PerPage+1) }</span>
					to 
					<span class="font-medium">
						{ fmt.Sprintf("%d", min(pagination.CurrentPage*pagination.PerPage, pagination.TotalItems)) }
					</span>
					of 
					<span class="font-medium">{ fmt.Sprintf("%d", pagination.TotalItems) }</span>
					results
				</p>
			</div>
			
			<div>
				<nav class="isolate inline-flex -space-x-px rounded-md shadow-sm" aria-label="Pagination">
					<!-- Previous Button -->
					if pagination.CurrentPage > 1 {
						<a 
							href={ templ.URL(fmt.Sprintf("?page=%d", pagination.CurrentPage-1)) }
							class="relative inline-flex items-center rounded-l-md px-2 py-2 text-gray-400 ring-1 ring-inset ring-gray-300 hover:bg-gray-50 focus:z-20 focus:outline-offset-0"
						>
							<span class="sr-only">Previous</span>
							<svg class="h-5 w-5" viewBox="0 0 20 20" fill="currentColor" aria-hidden="true">
								<path fill-rule="evenodd" d="M12.79 5.23a.75.75 0 01-.02 1.06L8.832 10l3.938 3.71a.75.75 0 11-1.04 1.08l-4.5-4.25a.75.75 0 010-1.08l4.5-4.25a.75.75 0 011.06.02z" clip-rule="evenodd"/>
							</svg>
						</a>
					} else {
						<span class="relative inline-flex items-center rounded-l-md px-2 py-2 text-gray-300 ring-1 ring-inset ring-gray-300">
							<span class="sr-only">Previous</span>
							<svg class="h-5 w-5" viewBox="0 0 20 20" fill="currentColor" aria-hidden="true">
								<path fill-rule="evenodd" d="M12.79 5.23a.75.75 0 01-.02 1.06L8.832 10l3.938 3.71a.75.75 0 11-1.04 1.08l-4.5-4.25a.75.75 0 010-1.08l4.5-4.25a.75.75 0 011.06.02z" clip-rule="evenodd"/>
							</svg>
						</span>
					}
					
					<!-- Page Numbers -->
					for _, pageNum := range getPaginationRange(pagination.CurrentPage, pagination.TotalPages) {
						if pageNum == -1 {
							<span class="relative inline-flex items-center px-4 py-2 text-sm font-semibold text-gray-700 ring-1 ring-inset ring-gray-300 focus:outline-offset-0">...</span>
						} else if pageNum == pagination.CurrentPage {
							<span class="relative z-10 inline-flex items-center bg-primary-600 px-4 py-2 text-sm font-semibold text-white focus:z-20 focus-visible:outline focus-visible:outline-2 focus-visible:outline-offset-2 focus-visible:outline-primary-600">
								{ fmt.Sprintf("%d", pageNum) }
							</span>
						} else {
							<a 
								href={ templ.URL(fmt.Sprintf("?page=%d", pageNum)) }
								class="relative inline-flex items-center px-4 py-2 text-sm font-semibold text-gray-900 ring-1 ring-inset ring-gray-300 hover:bg-gray-50 focus:z-20 focus:outline-offset-0"
							>
								{ fmt.Sprintf("%d", pageNum) }
							</a>
						}
					}
					
					<!-- Next Button -->
					if pagination.CurrentPage < pagination.TotalPages {
						<a 
							href={ templ.URL(fmt.Sprintf("?page=%d", pagination.CurrentPage+1)) }
							class="relative inline-flex items-center rounded-r-md px-2 py-2 text-gray-400 ring-1 ring-inset ring-gray-300 hover:bg-gray-50 focus:z-20 focus:outline-offset-0"
						>
							<span class="sr-only">Next</span>
							<svg class="h-5 w-5" viewBox="0 0 20 20" fill="currentColor" aria-hidden="true">
								<path fill-rule="evenodd" d="M7.21 14.77a.75.75 0 01.02-1.06L11.168 10 7.23 6.29a.75.75 0 111.04-1.08l4.5 4.25a.75.75 0 010 1.08l-4.5 4.25a.75.75 0 01-1.06-.02z" clip-rule="evenodd"/>
							</svg>
						</a>
					} else {
						<span class="relative inline-flex items-center rounded-r-md px-2 py-2 text-gray-300 ring-1 ring-inset ring-gray-300">
							<span class="sr-only">Next</span>
							<svg class="h-5 w-5" viewBox="0 0 20 20" fill="currentColor" aria-hidden="true">
								<path fill-rule="evenodd" d="M7.21 14.77a.75.75 0 01.02-1.06L11.168 10 7.23 6.29a.75.75 0 111.04-1.08l4.5 4.25a.75.75 0 010 1.08l-4.5 4.25a.75.75 0 01-1.06-.02z" clip-rule="evenodd"/>
							</svg>
						</span>
					}
				</nav>
			</div>
		</div>
	</div>
}

// Helper function to generate pagination range
func getPaginationRange(current, total int) []int {
	if total <= 7 {
		// Show all pages if total is small
		pages := make([]int, total)
		for i := 0; i < total; i++ {
			pages[i] = i + 1
		}
		return pages
	}
	
	var pages []int
	
	// Always show first page
	pages = append(pages, 1)
	
	if current <= 4 {
		// Show pages 1-5 and ellipsis and last page
		for i := 2; i <= 5; i++ {
			pages = append(pages, i)
		}
		if total > 6 {
			pages = append(pages, -1) // ellipsis
		}
		if total > 5 {
			pages = append(pages, total)
		}
	} else if current >= total-3 {
		// Show first page, ellipsis, and last 5 pages
		if total > 6 {
			pages = append(pages, -1) // ellipsis
		}
		for i := total - 4; i <= total; i++ {
			if i > 1 {
				pages = append(pages, i)
			}
		}
	} else {
		// Show first page, ellipsis, current-1, current, current+1, ellipsis, last page
		pages = append(pages, -1) // ellipsis
		for i := current - 1; i <= current+1; i++ {
			pages = append(pages, i)
		}
		pages = append(pages, -1) // ellipsis
		pages = append(pages, total)
	}
	
	return pages
}

func min(a, b int) int {
	if a < b {
		return a
	}
	return b
}